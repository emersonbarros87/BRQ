{"ast":null,"code":"export let CpfValidator = /*#__PURE__*/(() => {\n  class CpfValidator {}\n\n  CpfValidator.cpfValid = control => {\n    // Pega o valor que vem do controlador\n    const cpfString = String(control.value).replace(/\\D/g, ''); // Para verificar o digito do cpf\n\n    let rev = 0;\n    let add = 0; // Verifica tamanho digitado e alguns cpfs que passam na verificação do digito, mas são inválidos\n\n    if (cpfString.length !== 11 || cpfString === '00000000000' || cpfString === '11111111111' || cpfString === '22222222222' || cpfString === '33333333333' || cpfString === '44444444444' || cpfString === '55555555555' || cpfString === '66666666666' || cpfString === '77777777777' || cpfString === '88888888888' || cpfString === '99999999999') {\n      // Retorna um objeto contendo uma propriedade para identificar o erro e um valor.\n      // esse valor pode ser pego e adicionado a mensagem, porém para esse caso não precisamos.\n      return {\n        invalid: true\n      };\n    } // Valida o primeiro digito do CPF\n\n\n    add = 0;\n\n    for (let i = 1; i <= 9; i++) {\n      add += Number(cpfString.substring(i - 1, i)) * (11 - i);\n    }\n\n    rev = add * 10 % 11;\n\n    if (rev === 10 || rev === 11) {\n      rev = 0;\n    }\n\n    if (rev !== Number(cpfString.charAt(9))) {\n      return {\n        invalido: true\n      };\n    } // Valida o segundo digito do CPF\n\n\n    add = 0;\n\n    for (let i = 1; i <= 10; i++) {\n      add += Number(cpfString.substring(i - 1, i)) * (12 - i);\n    }\n\n    rev = add * 10 % 11;\n\n    if (rev === 10 || rev === 11) {\n      rev = 0;\n    }\n\n    if (rev !== Number(cpfString.charAt(10))) {\n      return {\n        invalido: true\n      };\n    } // Se tudo der certo e passou nas verificações returna null, ou seja, não possui erros nesse controlador\n\n\n    return null;\n  };\n\n  return CpfValidator;\n})();","map":null,"metadata":{},"sourceType":"module"}